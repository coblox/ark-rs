// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Round {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub start: i64,
    #[prost(int64, tag = "3")]
    pub end: i64,
    #[prost(string, tag = "4")]
    pub round_tx: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub vtxo_tree: ::core::option::Option<Tree>,
    #[prost(string, repeated, tag = "6")]
    pub forfeit_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub connectors: ::core::option::Option<Tree>,
    #[prost(enumeration = "RoundStage", tag = "8")]
    pub stage: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Outpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(oneof = "input::TaprootTree", tags = "2, 3")]
    pub taproot_tree: ::core::option::Option<input::TaprootTree>,
}
/// Nested message and enum types in `Input`.
pub mod input {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TaprootTree {
        #[prost(string, tag = "2")]
        Descriptor(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        Tapscripts(super::Tapscripts),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
    /// onchain or off-chain
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// Amount to send in satoshis.
    #[prost(uint64, tag = "2")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tree {
    #[prost(message, repeated, tag = "1")]
    pub levels: ::prost::alloc::vec::Vec<TreeLevel>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeLevel {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(bool, tag = "2")]
    pub spent: bool,
    #[prost(string, tag = "3")]
    pub round_txid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub spent_by: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub expire_at: i64,
    #[prost(bool, tag = "6")]
    pub swept: bool,
    #[prost(bool, tag = "7")]
    pub is_pending: bool,
    #[prost(string, tag = "8")]
    pub redeem_tx: ::prost::alloc::string::String,
    #[prost(uint64, tag = "9")]
    pub amount: u64,
    #[prost(string, tag = "10")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(int64, tag = "11")]
    pub created_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundTransaction {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "4")]
    pub claimed_boarding_utxos: ::prost::alloc::vec::Vec<Outpoint>,
    #[prost(string, tag = "5")]
    pub hex: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemTransaction {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(string, tag = "4")]
    pub hex: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tapscripts {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bip322Signature {
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketHour {
    #[prost(int64, tag = "1")]
    pub next_start_time: i64,
    #[prost(int64, tag = "2")]
    pub next_end_time: i64,
    #[prost(int64, tag = "3")]
    pub period: i64,
    #[prost(int64, tag = "4")]
    pub round_interval: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SweepableOutput {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub scheduled_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduledSweep {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<SweepableOutput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxRequestInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub created_at: i64,
    #[prost(message, repeated, tag = "3")]
    pub receivers: ::prost::alloc::vec::Vec<Output>,
    #[prost(message, repeated, tag = "4")]
    pub inputs: ::prost::alloc::vec::Vec<RequestInput>,
    #[prost(message, repeated, tag = "5")]
    pub boarding_inputs: ::prost::alloc::vec::Vec<RequestInput>,
    #[prost(string, repeated, tag = "6")]
    pub notes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "7")]
    pub signing_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "8")]
    pub cosigners_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "9")]
    pub last_ping: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestInput {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    #[prost(uint64, tag = "3")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundFinalizationEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub round_tx: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub vtxo_tree: ::core::option::Option<Tree>,
    #[prost(message, optional, tag = "4")]
    pub connectors: ::core::option::Option<Tree>,
    #[prost(int64, tag = "5")]
    pub min_relay_fee_rate: i64,
    /// vtxo outpoint encoded as string -> connector outpoint
    #[prost(map = "string, message", tag = "6")]
    pub connectors_index: ::std::collections::HashMap<::prost::alloc::string::String, Outpoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundFinalizedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub round_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundFailed {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundSigningEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub cosigners_pubkeys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "3")]
    pub unsigned_vtxo_tree: ::core::option::Option<Tree>,
    #[prost(string, tag = "4")]
    pub unsigned_round_tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundSigningNoncesGeneratedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tree_nonces: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoundStage {
    Unspecified = 0,
    Registration = 1,
    Finalization = 2,
    Finalized = 3,
    Failed = 4,
}
impl RoundStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ROUND_STAGE_UNSPECIFIED",
            Self::Registration => "ROUND_STAGE_REGISTRATION",
            Self::Finalization => "ROUND_STAGE_FINALIZATION",
            Self::Finalized => "ROUND_STAGE_FINALIZED",
            Self::Failed => "ROUND_STAGE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROUND_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "ROUND_STAGE_REGISTRATION" => Some(Self::Registration),
            "ROUND_STAGE_FINALIZATION" => Some(Self::Finalization),
            "ROUND_STAGE_FINALIZED" => Some(Self::Finalized),
            "ROUND_STAGE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetScheduledSweepRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScheduledSweepResponse {
    #[prost(message, repeated, tag = "1")]
    pub sweeps: ::prost::alloc::vec::Vec<ScheduledSweep>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundDetailsRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundDetailsResponse {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub forfeited_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub total_vtxos_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub total_exit_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub fees_amount: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub inputs_vtxos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub outputs_vtxos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub exit_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRoundsRequest {
    #[prost(int64, tag = "1")]
    pub after: i64,
    #[prost(int64, tag = "2")]
    pub before: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundsResponse {
    #[prost(string, repeated, tag = "1")]
    pub rounds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateNoteRequest {
    #[prost(uint32, tag = "1")]
    pub amount: u32,
    #[prost(uint32, tag = "2")]
    pub quantity: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNoteResponse {
    #[prost(string, repeated, tag = "1")]
    pub notes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMarketHourConfigRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMarketHourConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<MarketHourConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateMarketHourConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<MarketHourConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateMarketHourConfigResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketHourConfig {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub period: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub round_interval: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTxRequestQueueRequest {
    #[prost(string, repeated, tag = "1")]
    pub request_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTxRequestQueueResponse {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<TxRequestInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTxRequestsRequest {
    #[prost(string, repeated, tag = "1")]
    pub request_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTxRequestsResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawResponse {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod admin_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct AdminServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdminServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdminServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdminServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdminServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_scheduled_sweep(
            &mut self,
            request: impl tonic::IntoRequest<super::GetScheduledSweepRequest>,
        ) -> std::result::Result<tonic::Response<super::GetScheduledSweepResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetScheduledSweep");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetScheduledSweep"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_round_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetRoundDetails");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetRoundDetails"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_rounds(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetRounds");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetRounds"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_note(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNoteRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateNoteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/CreateNote");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "CreateNote"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_market_hour_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMarketHourConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMarketHourConfigResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetMarketHourConfig");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "GetMarketHourConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_market_hour_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMarketHourConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateMarketHourConfigResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/UpdateMarketHourConfig");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "UpdateMarketHourConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_tx_request_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTxRequestQueueRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTxRequestQueueResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetTxRequestQueue");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetTxRequestQueue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_tx_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTxRequestsRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteTxRequestsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/DeleteTxRequests");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "DeleteTxRequests"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<super::WithdrawRequest>,
        ) -> std::result::Result<tonic::Response<super::WithdrawResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/Withdraw");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "Withdraw"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub vtxo_tree_expiry: i64,
    #[prost(int64, tag = "3")]
    pub unilateral_exit_delay: i64,
    #[prost(int64, tag = "4")]
    pub round_interval: i64,
    #[prost(string, tag = "5")]
    pub network: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub dust: i64,
    #[prost(string, tag = "7")]
    pub boarding_descriptor_template: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "8")]
    pub vtxo_descriptor_templates: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "9")]
    pub forfeit_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub market_hour: ::core::option::Option<MarketHour>,
    #[prost(string, tag = "11")]
    pub version: ::prost::alloc::string::String,
    /// -1 means native dust limit (default)
    #[prost(int64, tag = "12")]
    pub utxo_min_amount: i64,
    /// -1 means no limit (default), 0 means boarding not allowed
    #[prost(int64, tag = "13")]
    pub utxo_max_amount: i64,
    /// -1 means native dust limit (default)
    #[prost(int64, tag = "14")]
    pub vtxo_min_amount: i64,
    /// -1 means no limit (default)
    #[prost(int64, tag = "15")]
    pub vtxo_max_amount: i64,
    #[prost(int64, tag = "16")]
    pub boarding_exit_delay: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardingAddressRequest {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardingAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(oneof = "get_boarding_address_response::TaprootTree", tags = "2, 3")]
    pub taproot_tree: ::core::option::Option<get_boarding_address_response::TaprootTree>,
}
/// Nested message and enum types in `GetBoardingAddressResponse`.
pub mod get_boarding_address_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum TaprootTree {
        #[prost(string, tag = "2")]
        Descriptor(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        Tapscripts(super::Tapscripts),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterIntentRequest {
    /// BIP322 signature embeds the outpoints and the proof of funds
    #[prost(message, optional, tag = "1")]
    pub bip322_signature: ::core::option::Option<Bip322Signature>,
    #[prost(string, repeated, tag = "2")]
    pub notes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterIntentResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterInputsForNextRoundRequest {
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
    #[prost(string, repeated, tag = "2")]
    pub notes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterInputsForNextRoundResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Musig2 {
    #[prost(string, repeated, tag = "1")]
    pub cosigners_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub signing_all: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterOutputsForNextRoundRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// List of receivers for to convert to leaves in the next VTXO tree.
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<Output>,
    #[prost(message, optional, tag = "3")]
    pub musig2: ::core::option::Option<Musig2>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterOutputsForNextRoundResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tree_nonces: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tree_signatures: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitSignedForfeitTxsRequest {
    /// Forfeit txs signed by the user.
    #[prost(string, repeated, tag = "1")]
    pub signed_forfeit_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The user has to sign also the round tx if he registerd a boarding UTXO.
    #[prost(string, optional, tag = "2")]
    pub signed_round_tx: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitSignedForfeitTxsResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetEventStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventStreamResponse {
    #[prost(oneof = "get_event_stream_response::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<get_event_stream_response::Event>,
}
/// Nested message and enum types in `GetEventStreamResponse`.
pub mod get_event_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        RoundFinalization(super::RoundFinalizationEvent),
        #[prost(message, tag = "2")]
        RoundFinalized(super::RoundFinalizedEvent),
        #[prost(message, tag = "3")]
        RoundFailed(super::RoundFailed),
        #[prost(message, tag = "4")]
        RoundSigning(super::RoundSigningEvent),
        #[prost(message, tag = "5")]
        RoundSigningNoncesGenerated(super::RoundSigningNoncesGeneratedEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PingRequest {
    /// The id used to register inputs and ouptuts.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PingResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitRedeemTxRequest {
    #[prost(string, tag = "1")]
    pub redeem_tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitRedeemTxResponse {
    #[prost(string, tag = "1")]
    pub signed_redeem_tx: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamResponse {
    #[prost(oneof = "get_transactions_stream_response::Tx", tags = "1, 2")]
    pub tx: ::core::option::Option<get_transactions_stream_response::Tx>,
}
/// Nested message and enum types in `GetTransactionsStreamResponse`.
pub mod get_transactions_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Tx {
        #[prost(message, tag = "1")]
        Round(super::RoundTransaction),
        #[prost(message, tag = "2")]
        Redeem(super::RedeemTransaction),
    }
}
/// Generated client implementations.
pub mod ark_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ArkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ArkServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ArkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ArkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ArkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetInfo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_boarding_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBoardingAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBoardingAddressResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetBoardingAddress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetBoardingAddress"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/RegisterIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "RegisterIntent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_inputs_for_next_round(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterInputsForNextRoundRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterInputsForNextRoundResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.ArkService/RegisterInputsForNextRound",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "RegisterInputsForNextRound",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_outputs_for_next_round(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterOutputsForNextRoundRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterOutputsForNextRoundResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.ArkService/RegisterOutputsForNextRound",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "RegisterOutputsForNextRound",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_tree_nonces(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeNoncesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeNoncesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeNonces");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeNonces"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_tree_signatures(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeSignaturesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeSignaturesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeSignatures");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeSignatures"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_signed_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitSignedForfeitTxsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitSignedForfeitTxsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitSignedForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "SubmitSignedForfeitTxs",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_event_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetEventStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetEventStream");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetEventStream"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn ping(
            &mut self,
            request: impl tonic::IntoRequest<super::PingRequest>,
        ) -> std::result::Result<tonic::Response<super::PingResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/Ping");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "Ping"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_redeem_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitRedeemTxRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitRedeemTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitRedeemTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitRedeemTx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transactions_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionsStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetTransactionsStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetTransactionsStream");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "GetTransactionsStream",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenSeedRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenSeedResponse {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub gap_limit: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestoreResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockRequest {
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LockRequest {
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStatusRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStatusResponse {
    #[prost(bool, tag = "1")]
    pub initialized: bool,
    #[prost(bool, tag = "2")]
    pub unlocked: bool,
    #[prost(bool, tag = "3")]
    pub synced: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeriveAddressRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeriveAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Balance {
    #[prost(string, tag = "1")]
    pub locked: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub available: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(message, optional, tag = "1")]
    pub main_account: ::core::option::Option<Balance>,
    #[prost(message, optional, tag = "2")]
    pub connectors_account: ::core::option::Option<Balance>,
}
/// Generated client implementations.
pub mod wallet_initializer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletInitializerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletInitializerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletInitializerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletInitializerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletInitializerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn gen_seed(
            &mut self,
            request: impl tonic::IntoRequest<super::GenSeedRequest>,
        ) -> std::result::Result<tonic::Response<super::GenSeedResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GenSeed");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GenSeed",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Create");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restore(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreRequest>,
        ) -> std::result::Result<tonic::Response<super::RestoreResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Restore");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "Restore",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unlock(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockRequest>,
        ) -> std::result::Result<tonic::Response<super::UnlockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Unlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Unlock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStatusResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GetStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod wallet_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn lock(
            &mut self,
            request: impl tonic::IntoRequest<super::LockRequest>,
        ) -> std::result::Result<tonic::Response<super::LockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/Lock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "Lock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn derive_address(
            &mut self,
            request: impl tonic::IntoRequest<super::DeriveAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::DeriveAddressResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/DeriveAddress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "DeriveAddress"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundResponse {
    #[prost(message, optional, tag = "1")]
    pub round: ::core::option::Option<Round>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundByIdRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundByIdResponse {
    #[prost(message, optional, tag = "1")]
    pub round: ::core::option::Option<Round>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVtxosRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVtxosResponse {
    #[prost(message, repeated, tag = "1")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForAddressRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForAddressResponse {
    #[prost(message, repeated, tag = "2")]
    pub new_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
}
/// Generated client implementations.
pub mod explorer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ExplorerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ExplorerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ExplorerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ExplorerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ExplorerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_round(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/GetRound");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ExplorerService", "GetRound"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_round_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundByIdRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundByIdResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/GetRoundById");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ExplorerService", "GetRoundById"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_vtxos(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVtxosRequest>,
        ) -> std::result::Result<tonic::Response<super::ListVtxosResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/ListVtxos");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ExplorerService", "ListVtxos"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn subscribe_for_address(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeForAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SubscribeForAddressResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/SubscribeForAddress");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ExplorerService",
                "SubscribeForAddress",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
