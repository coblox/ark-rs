// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Outpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(message, optional, tag = "2")]
    pub taproot_tree: ::core::option::Option<Tapscripts>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
    /// onchain or off-chain
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// Amount to send in satoshis.
    #[prost(uint64, tag = "2")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(uint64, tag = "2")]
    pub amount: u64,
    #[prost(string, tag = "3")]
    pub script: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub created_at: i64,
    #[prost(int64, tag = "5")]
    pub expires_at: i64,
    #[prost(string, tag = "6")]
    pub commitment_txid: ::prost::alloc::string::String,
    #[prost(bool, tag = "7")]
    pub preconfirmed: bool,
    #[prost(bool, tag = "8")]
    pub swept: bool,
    #[prost(bool, tag = "9")]
    pub redeemed: bool,
    #[prost(bool, tag = "10")]
    pub spent: bool,
    #[prost(string, tag = "11")]
    pub spent_by: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxNotification {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(string, tag = "5")]
    pub hex: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tapscripts {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bip322Signature {
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketHour {
    #[prost(int64, tag = "1")]
    pub next_start_time: i64,
    #[prost(int64, tag = "2")]
    pub next_end_time: i64,
    #[prost(int64, tag = "3")]
    pub period: i64,
    #[prost(int64, tag = "4")]
    pub round_interval: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchStartedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub intent_id_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub batch_expiry: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchFinalizationEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commitment_tx: ::prost::alloc::string::String,
    /// vtxo outpoint encoded as string -> connector outpoint
    #[prost(map = "string, message", tag = "3")]
    pub connectors_index: ::std::collections::HashMap<::prost::alloc::string::String, Outpoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchFinalizedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub commitment_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchFailed {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeSigningStartedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub cosigners_pubkeys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub unsigned_commitment_tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeNoncesAggregatedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tree_nonces: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeTxEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub batch_index: i32,
    #[prost(string, tag = "4")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub tx: ::prost::alloc::string::String,
    /// output index -> child txid
    #[prost(map = "uint32, string", tag = "6")]
    pub children: ::std::collections::HashMap<u32, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeSignatureEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub batch_index: i32,
    #[prost(string, tag = "4")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub vtxo_tree_expiry: i64,
    #[prost(int64, tag = "3")]
    pub unilateral_exit_delay: i64,
    #[prost(int64, tag = "4")]
    pub round_interval: i64,
    #[prost(string, tag = "5")]
    pub network: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub dust: i64,
    #[prost(string, tag = "7")]
    pub forfeit_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub market_hour: ::core::option::Option<MarketHour>,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(int64, tag = "10")]
    pub utxo_min_amount: i64,
    /// -1 means no limit (default), 0 means boarding not allowed
    #[prost(int64, tag = "11")]
    pub utxo_max_amount: i64,
    #[prost(int64, tag = "12")]
    pub vtxo_min_amount: i64,
    /// -1 means no limit (default)
    #[prost(int64, tag = "13")]
    pub vtxo_max_amount: i64,
    #[prost(int64, tag = "14")]
    pub boarding_exit_delay: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterIntentRequest {
    /// BIP322 signature embeds the outpoints to be spent and new ones to be created, as well as
    /// the the proof of funds.
    #[prost(message, optional, tag = "1")]
    pub intent: ::core::option::Option<Bip322Signature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterIntentResponse {
    #[prost(string, tag = "1")]
    pub intent_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIntentRequest {
    /// A BIP322 signature that includes any of the inputs of the intent to be deleted to prove the
    /// ownership of that intent.
    #[prost(message, optional, tag = "2")]
    pub proof: ::core::option::Option<Bip322Signature>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteIntentResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfirmRegistrationRequest {
    #[prost(string, tag = "1")]
    pub intent_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfirmRegistrationResponse {
    #[prost(string, tag = "1")]
    pub blinded_creds: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesRequest {
    #[prost(string, tag = "1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tree_nonces: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesRequest {
    #[prost(string, tag = "1")]
    pub batch_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tree_signatures: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitSignedForfeitTxsRequest {
    /// Forfeit txs signed by the user.
    #[prost(string, repeated, tag = "1")]
    pub signed_forfeit_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The user has to sign also the commitment tx if he registered a boarding UTXO.
    #[prost(string, tag = "2")]
    pub signed_commitment_tx: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitSignedForfeitTxsResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetEventStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventStreamResponse {
    #[prost(
        oneof = "get_event_stream_response::Event",
        tags = "1, 2, 3, 4, 5, 6, 7, 8"
    )]
    pub event: ::core::option::Option<get_event_stream_response::Event>,
}
/// Nested message and enum types in `GetEventStreamResponse`.
pub mod get_event_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        BatchStarted(super::BatchStartedEvent),
        #[prost(message, tag = "2")]
        BatchFinalization(super::BatchFinalizationEvent),
        #[prost(message, tag = "3")]
        BatchFinalized(super::BatchFinalizedEvent),
        #[prost(message, tag = "4")]
        BatchFailed(super::BatchFailed),
        #[prost(message, tag = "5")]
        TreeSigningStarted(super::TreeSigningStartedEvent),
        #[prost(message, tag = "6")]
        TreeNoncesAggregated(super::TreeNoncesAggregatedEvent),
        #[prost(message, tag = "7")]
        TreeTx(super::TreeTxEvent),
        #[prost(message, tag = "8")]
        TreeSignature(super::TreeSignatureEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTxRequest {
    #[prost(string, tag = "1")]
    pub signed_ark_tx: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTxResponse {
    #[prost(string, tag = "1")]
    pub ark_txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub final_ark_tx: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub signed_checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeTxRequest {
    #[prost(string, tag = "1")]
    pub ark_txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub final_checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinalizeTxResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamResponse {
    #[prost(oneof = "get_transactions_stream_response::Tx", tags = "1, 2")]
    pub tx: ::core::option::Option<get_transactions_stream_response::Tx>,
}
/// Nested message and enum types in `GetTransactionsStreamResponse`.
pub mod get_transactions_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Tx {
        #[prost(message, tag = "1")]
        CommitmentTx(super::TxNotification),
        #[prost(message, tag = "2")]
        ArkTx(super::TxNotification),
    }
}
/// Generated client implementations.
pub mod ark_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ArkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ArkServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ArkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ArkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ArkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// GetInfo returns information and parameters of the server.
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetInfo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// RegisterIntent allows to register a new intent that will be eventually selected by the
        /// server for a particular batch.
        /// The client should provide a BIP-322 message with the intent information, and the server
        /// should respond with an intent id.
        pub async fn register_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/RegisterIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "RegisterIntent"));
            self.inner.unary(req, path, codec).await
        }
        /// DeleteIntent removes a previously registered intent from the server.
        /// The client should provide the BIP-322 signature and message including any of the vtxos
        /// used in the registered intent to prove its ownership.
        /// The server should delete the intent and return success.
        pub async fn delete_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/DeleteIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "DeleteIntent"));
            self.inner.unary(req, path, codec).await
        }
        /// ConfirmRegistration allows a client that has been selected for the next batch to confirm
        /// its participation by revealing the intent id.
        pub async fn confirm_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfirmRegistrationRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfirmRegistrationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/ConfirmRegistration");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "ConfirmRegistration"));
            self.inner.unary(req, path, codec).await
        }
        /// SubmitTreeNonces allows a cosigner to submit the tree nonces for the musig2 session of a
        /// given batch.
        /// The client should provide the batch id, the cosigner public key, and the tree nonces.
        /// The server should verify the cosigner public key and the nonces, and store them for
        /// later aggregation once nonces from all clients are collected.
        pub async fn submit_tree_nonces(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeNoncesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeNoncesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeNonces");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeNonces"));
            self.inner.unary(req, path, codec).await
        }
        /// SubmitTreeSignatures allows a cosigner to submit the tree signatures for the musig2
        /// session of a given batch.
        /// The client should provide the batch id, the cosigner public key, and the tree
        /// signatures. The server should verify the cosigner public key and the signatures,
        /// and store them for later aggregation once signatures from all clients are
        /// collected.
        pub async fn submit_tree_signatures(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeSignaturesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeSignaturesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeSignatures");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeSignatures"));
            self.inner.unary(req, path, codec).await
        }
        /// SubmitSignedForfeitTxs allows a client to submit signed forfeit transactions and/or
        /// signed commitment transaction (in case of onboarding).
        /// The server should verify the signed txs and return success.
        pub async fn submit_signed_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitSignedForfeitTxsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitSignedForfeitTxsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitSignedForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "SubmitSignedForfeitTxs",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetEventStream is a server-side streaming RPC that allows clients to receive a stream of
        /// events related to batch processing.
        /// Clients should use this stream as soon as they are ready to join a batch and can listen
        /// for various events such as batch start, batch finalization, and other related
        /// activities. The server pushes these events to the client in real-time as soon as
        /// its ready to move to the next phase of the batch processing.
        pub async fn get_event_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetEventStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetEventStream");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetEventStream"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// SubmitTx is the first leg of the process of spending vtxos offchain and allows a client
        /// to submit a signed Ark transaction and the unsigned checkpoint transactions.
        /// The server should verify the signed transactions and return the fully signed Ark tx and
        /// the signed checkpoint txs.
        pub async fn submit_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTxRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTxResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTx"));
            self.inner.unary(req, path, codec).await
        }
        /// FinalizeTx is the last lef of the process of spending vtxos offchain and allows a client
        /// to submit the fully signed checkpoint txs for the provided Ark txid .
        /// The server verifies the signed checkpoint transactions and returns success if everything
        /// is valid.
        pub async fn finalize_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeTxRequest>,
        ) -> std::result::Result<tonic::Response<super::FinalizeTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/FinalizeTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "FinalizeTx"));
            self.inner.unary(req, path, codec).await
        }
        /// GetTransactionsStream is a server-side streaming RPC that allows clients to receive
        /// notifications in real-time about any commitment tx or ark tx processed and finalized by
        /// the server.
        /// NOTE: the stream doesn't have history support, therefore returns only txs from the
        /// moment it's opened until it's closed.
        pub async fn get_transactions_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionsStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetTransactionsStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetTransactionsStream");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "GetTransactionsStream",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenSeedRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenSeedResponse {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub gap_limit: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestoreResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockRequest {
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStatusRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStatusResponse {
    #[prost(bool, tag = "1")]
    pub initialized: bool,
    #[prost(bool, tag = "2")]
    pub unlocked: bool,
    #[prost(bool, tag = "3")]
    pub synced: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeriveAddressRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeriveAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Balance {
    #[prost(string, tag = "1")]
    pub locked: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub available: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(message, optional, tag = "1")]
    pub main_account: ::core::option::Option<Balance>,
    #[prost(message, optional, tag = "2")]
    pub connectors_account: ::core::option::Option<Balance>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawResponse {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod wallet_initializer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletInitializerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletInitializerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletInitializerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletInitializerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletInitializerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn gen_seed(
            &mut self,
            request: impl tonic::IntoRequest<super::GenSeedRequest>,
        ) -> std::result::Result<tonic::Response<super::GenSeedResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GenSeed");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GenSeed",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Create");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restore(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreRequest>,
        ) -> std::result::Result<tonic::Response<super::RestoreResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Restore");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "Restore",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unlock(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockRequest>,
        ) -> std::result::Result<tonic::Response<super::UnlockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Unlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Unlock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStatusResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GetStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod wallet_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn lock(
            &mut self,
            request: impl tonic::IntoRequest<super::LockRequest>,
        ) -> std::result::Result<tonic::Response<super::LockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/Lock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "Lock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn derive_address(
            &mut self,
            request: impl tonic::IntoRequest<super::DeriveAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::DeriveAddressResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/DeriveAddress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "DeriveAddress"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<super::WithdrawRequest>,
        ) -> std::result::Result<tonic::Response<super::WithdrawResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/Withdraw");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "Withdraw"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxResponse {
    #[prost(int64, tag = "1")]
    pub started_at: i64,
    #[prost(int64, tag = "2")]
    pub ended_at: i64,
    #[prost(map = "uint32, message", tag = "3")]
    pub batches: ::std::collections::HashMap<u32, IndexerBatch>,
    #[prost(uint64, tag = "4")]
    pub total_input_amount: u64,
    #[prost(int32, tag = "5")]
    pub total_input_vtxos: i32,
    #[prost(uint64, tag = "6")]
    pub total_output_amount: u64,
    #[prost(int32, tag = "7")]
    pub total_output_vtxos: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetForfeitTxsRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetForfeitTxsResponse {
    #[prost(string, repeated, tag = "1")]
    pub txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorsRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connectors: ::prost::alloc::vec::Vec<IndexerNode>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxLeavesRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxLeavesResponse {
    #[prost(message, repeated, tag = "1")]
    pub leaves: ::prost::alloc::vec::Vec<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxo_tree: ::prost::alloc::vec::Vec<IndexerNode>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeLeavesRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeLeavesResponse {
    #[prost(message, repeated, tag = "1")]
    pub leaves: ::prost::alloc::vec::Vec<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosRequest {
    /// Either specify a list of addresses to list the vtxos for
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Or specify a list of outpoints. The 2 filters are mutually exclusive
    #[prost(string, repeated, tag = "2")]
    pub outpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Retrieve only spendable vtxos
    #[prost(bool, tag = "3")]
    pub spendable_only: bool,
    /// Retrieve only spendable vtxos. The 2 filters are mutually exclusive
    #[prost(bool, tag = "4")]
    pub spent_only: bool,
    #[prost(message, optional, tag = "5")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionHistoryRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub start_time: i64,
    #[prost(int64, tag = "3")]
    pub end_time: i64,
    #[prost(message, optional, tag = "4")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub history: ::prost::alloc::vec::Vec<IndexerTxHistoryRecord>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoChainRequest {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoChainResponse {
    #[prost(message, repeated, tag = "1")]
    pub chain: ::prost::alloc::vec::Vec<IndexerChain>,
    #[prost(int32, tag = "2")]
    pub depth: i32,
    #[prost(string, tag = "3")]
    pub root_commitment_txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVirtualTxsRequest {
    #[prost(string, repeated, tag = "1")]
    pub txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVirtualTxsResponse {
    #[prost(string, repeated, tag = "1")]
    pub txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSweptCommitmentTxRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSweptCommitmentTxResponse {
    #[prost(string, repeated, tag = "1")]
    pub swept_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexerBatch {
    #[prost(uint64, tag = "1")]
    pub total_output_amount: u64,
    #[prost(int32, tag = "2")]
    pub total_output_vtxos: i32,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
    #[prost(bool, tag = "4")]
    pub swept: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerOutpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerNode {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    /// vout -> txid
    #[prost(map = "uint32, string", tag = "2")]
    pub children: ::std::collections::HashMap<u32, ::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerVtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(int64, tag = "2")]
    pub created_at: i64,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    #[prost(string, tag = "5")]
    pub script: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub is_preconfirmed: bool,
    #[prost(bool, tag = "7")]
    pub is_swept: bool,
    #[prost(bool, tag = "8")]
    pub is_redeemed: bool,
    #[prost(bool, tag = "9")]
    pub is_spent: bool,
    #[prost(string, tag = "10")]
    pub spent_by: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub commitment_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerChain {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spends: ::prost::alloc::vec::Vec<IndexerChainedTx>,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerChainedTx {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(enumeration = "IndexerChainedTxType", tag = "2")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerTxHistoryRecord {
    #[prost(enumeration = "IndexerTxType", tag = "3")]
    pub r#type: i32,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    #[prost(int64, tag = "5")]
    pub created_at: i64,
    #[prost(bool, tag = "6")]
    pub is_settled: bool,
    #[prost(string, tag = "7")]
    pub settled_by: ::prost::alloc::string::String,
    #[prost(oneof = "indexer_tx_history_record::Key", tags = "1, 2")]
    pub key: ::core::option::Option<indexer_tx_history_record::Key>,
}
/// Nested message and enum types in `IndexerTxHistoryRecord`.
pub mod indexer_tx_history_record {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Key {
        #[prost(string, tag = "1")]
        CommitmentTxid(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        VirtualTxid(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexerPageRequest {
    #[prost(int32, tag = "1")]
    pub size: i32,
    #[prost(int32, tag = "2")]
    pub index: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexerPageResponse {
    #[prost(int32, tag = "1")]
    pub current: i32,
    #[prost(int32, tag = "2")]
    pub next: i32,
    #[prost(int32, tag = "3")]
    pub total: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForScriptsRequest {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// If set, update an existing subscription
    #[prost(string, tag = "2")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForScriptsResponse {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsubscribeForScriptsRequest {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
    /// If empty, unsubscribe all scripts
    #[prost(string, repeated, tag = "2")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnsubscribeForScriptsResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionResponse {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub new_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, repeated, tag = "4")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexerTxType {
    Unspecified = 0,
    Received = 1,
    Sent = 2,
}
impl IndexerTxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXER_TX_TYPE_UNSPECIFIED",
            Self::Received => "INDEXER_TX_TYPE_RECEIVED",
            Self::Sent => "INDEXER_TX_TYPE_SENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXER_TX_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXER_TX_TYPE_RECEIVED" => Some(Self::Received),
            "INDEXER_TX_TYPE_SENT" => Some(Self::Sent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexerChainedTxType {
    Unspecified = 0,
    Virtual = 1,
    Commitment = 2,
}
impl IndexerChainedTxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED",
            Self::Virtual => "INDEXER_CHAINED_TX_TYPE_VIRTUAL",
            Self::Commitment => "INDEXER_CHAINED_TX_TYPE_COMMITMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXER_CHAINED_TX_TYPE_VIRTUAL" => Some(Self::Virtual),
            "INDEXER_CHAINED_TX_TYPE_COMMITMENT" => Some(Self::Commitment),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod indexer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct IndexerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IndexerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IndexerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IndexerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IndexerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// GetCommitmentTx returns information about a specific commitment transaction identified
        /// by the provided txid.
        pub async fn get_commitment_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommitmentTxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCommitmentTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetCommitmentTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetCommitmentTx"));
            self.inner.unary(req, path, codec).await
        }
        /// GetForfeitTxs returns the list of forfeit transactions that were submitted for the
        /// provided commitment transaction.
        /// The response may include pagination information if the results span multiple pages.
        pub async fn get_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetForfeitTxsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetForfeitTxsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetForfeitTxs"));
            self.inner.unary(req, path, codec).await
        }
        /// GetConnectors returns the tree of connectors for the provided commitment transaction.
        /// The response includes a list of connector txs with details on the tree posistion and may
        /// include pagination information if the results span multiple pages.
        pub async fn get_connectors(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectorsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConnectorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetConnectors");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetConnectors"));
            self.inner.unary(req, path, codec).await
        }
        /// GetCommitmentTxLeaves returns the list of leaves (vtxo outpoints) of all batch outputs'
        /// trees included in the provided commitment transaction.
        /// The response may include pagination information if the results span multiple pages.
        pub async fn get_commitment_tx_leaves(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommitmentTxLeavesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCommitmentTxLeavesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/GetCommitmentTxLeaves",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetCommitmentTxLeaves",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxoTree returns the vtxo tree for the provided batch outpoint.
        /// The response includes a list of txs with details on the tree posistion and may
        /// include pagination information if the results span multiple pages.
        pub async fn get_vtxo_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoTreeRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoTreeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoTree");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxoTree"));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxoTreeLeaves returns the list of leaves (vtxo outpoints) of the tree(s) for the
        /// provided batch outpoint.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_vtxo_tree_leaves(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoTreeLeavesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoTreeLeavesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoTreeLeaves");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetVtxoTreeLeaves",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxos returns the list of vtxos based on the provided filter. Vtxos can be retrieved
        /// either by addresses or by outpoints, and optionally filtered by spendable or
        /// spent only. The response may be paginated if the results span multiple pages.
        pub async fn get_vtxos(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxosRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxosResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxos");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxos"));
            self.inner.unary(req, path, codec).await
        }
        /// GetTransactionHistory returns the list of transactions for the provided address.
        /// The tx history can be filtered by defining a start and/or end time.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_transaction_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionHistoryRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTransactionHistoryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/GetTransactionHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetTransactionHistory",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetVtxoChain returns the the chain of ark txs that starts from spending any vtxo leaf
        /// and ends with the creation of the provided vtxo outpoint.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_vtxo_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoChainRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoChainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoChain");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxoChain"));
            self.inner.unary(req, path, codec).await
        }
        /// GetVirtualTxs returns the virtual transactions in hex format for the specified txids.
        /// The response may be paginated if the results span multiple pages.
        pub async fn get_virtual_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVirtualTxsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVirtualTxsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVirtualTxs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVirtualTxs"));
            self.inner.unary(req, path, codec).await
        }
        /// GetSweptCommitmentTx returns the list of transaction (txid) that swept each batch output
        /// of the specified commitment transaction.
        /// In most cases the list contains only one txid per batch, that means the funds locked in
        /// the batch output have been claimed back.
        /// If any of the leaves of the tree (vtxo) have been unrolled onchain before the
        /// expiration, the list will contain many txids.
        /// In a binary tree with 4 or more leaves, 1 unroll causes the server to broadcast 3 txs to
        /// sweep the whole tree for example.
        /// If a whole vtxo tree has been unrolled onchain, the list of txids for that batch output
        /// is be empty.
        pub async fn get_swept_commitment_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSweptCommitmentTxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSweptCommitmentTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetSweptCommitmentTx");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetSweptCommitmentTx",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// SubscribeForScripts allows to subscribe for tx notifications related to the provided
        /// vtxo scripts. It can also be used to update an existing subscribtion by adding
        /// new scripts to it.
        pub async fn subscribe_for_scripts(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeForScriptsRequest>,
        ) -> std::result::Result<tonic::Response<super::SubscribeForScriptsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/SubscribeForScripts");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "SubscribeForScripts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// UnsubscribeForScripts allows to remove scripts from an existing subscription.
        pub async fn unsubscribe_for_scripts(
            &mut self,
            request: impl tonic::IntoRequest<super::UnsubscribeForScriptsRequest>,
        ) -> std::result::Result<tonic::Response<super::UnsubscribeForScriptsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/UnsubscribeForScripts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "UnsubscribeForScripts",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// GetSubscription is a server-side streaming RPC which allows clients to receive real-time
        /// notifications on transactions related to the subscribed vtxo scripts.
        /// The subscription can be created or updated by using the SubscribeForScripts and
        /// UnsubscribeForScripts RPCs.
        pub async fn get_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetSubscriptionResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetSubscription");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetSubscription"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
