// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Round {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub start: i64,
    #[prost(int64, tag = "3")]
    pub end: i64,
    #[prost(string, tag = "4")]
    pub round_tx: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub vtxo_tree: ::core::option::Option<Tree>,
    #[prost(string, repeated, tag = "6")]
    pub forfeit_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "7")]
    pub connectors: ::core::option::Option<Tree>,
    #[prost(enumeration = "RoundStage", tag = "8")]
    pub stage: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Outpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Input {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(message, optional, tag = "2")]
    pub taproot_tree: ::core::option::Option<Tapscripts>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Output {
    /// onchain or off-chain
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// Amount to send in satoshis.
    #[prost(uint64, tag = "2")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tree {
    #[prost(message, repeated, tag = "1")]
    pub levels: ::prost::alloc::vec::Vec<TreeLevel>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TreeLevel {
    #[prost(message, repeated, tag = "1")]
    pub nodes: ::prost::alloc::vec::Vec<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Node {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tx: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent_txid: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub level: i32,
    #[prost(int32, tag = "5")]
    pub level_index: i32,
    #[prost(bool, tag = "6")]
    pub leaf: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Vtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<Outpoint>,
    #[prost(bool, tag = "2")]
    pub spent: bool,
    #[prost(string, tag = "3")]
    pub round_txid: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub spent_by: ::prost::alloc::string::String,
    #[prost(int64, tag = "5")]
    pub expire_at: i64,
    #[prost(bool, tag = "6")]
    pub swept: bool,
    #[prost(bool, tag = "7")]
    pub is_pending: bool,
    #[prost(string, tag = "8")]
    pub redeem_tx: ::prost::alloc::string::String,
    #[prost(uint64, tag = "9")]
    pub amount: u64,
    #[prost(string, tag = "10")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(int64, tag = "11")]
    pub created_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundTransaction {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "4")]
    pub claimed_boarding_utxos: ::prost::alloc::vec::Vec<Outpoint>,
    #[prost(string, tag = "5")]
    pub hex: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedeemTransaction {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(string, tag = "4")]
    pub hex: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tapscripts {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bip322Signature {
    #[prost(string, tag = "1")]
    pub signature: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketHour {
    #[prost(int64, tag = "1")]
    pub next_start_time: i64,
    #[prost(int64, tag = "2")]
    pub next_end_time: i64,
    #[prost(int64, tag = "3")]
    pub period: i64,
    #[prost(int64, tag = "4")]
    pub round_interval: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SweepableOutput {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    #[prost(string, tag = "3")]
    pub amount: ::prost::alloc::string::String,
    #[prost(int64, tag = "4")]
    pub scheduled_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduledSweep {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<SweepableOutput>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxRequestInfo {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub created_at: i64,
    #[prost(message, repeated, tag = "3")]
    pub receivers: ::prost::alloc::vec::Vec<Output>,
    #[prost(message, repeated, tag = "4")]
    pub inputs: ::prost::alloc::vec::Vec<RequestInput>,
    #[prost(message, repeated, tag = "5")]
    pub boarding_inputs: ::prost::alloc::vec::Vec<RequestInput>,
    #[prost(string, repeated, tag = "6")]
    pub cosigners_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestInput {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
    #[prost(uint64, tag = "3")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchStartedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub intent_id_hashes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "3")]
    pub batch_expiry: i64,
    #[prost(string, tag = "4")]
    pub forfeit_address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundFinalizationEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub round_tx: ::prost::alloc::string::String,
    /// vtxo outpoint encoded as string -> connector outpoint
    #[prost(map = "string, message", tag = "3")]
    pub connectors_index: ::std::collections::HashMap<::prost::alloc::string::String, Outpoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundFinalizedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub round_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundFailed {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundSigningEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub cosigners_pubkeys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "3")]
    pub unsigned_round_tx: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RoundSigningNoncesGeneratedEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tree_nonces: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchTreeEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub batch_index: i32,
    #[prost(message, optional, tag = "4")]
    pub tree_tx: ::core::option::Option<Node>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchTreeSignatureEvent {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub topic: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, tag = "3")]
    pub batch_index: i32,
    #[prost(int32, tag = "4")]
    pub level: i32,
    #[prost(int32, tag = "5")]
    pub level_index: i32,
    #[prost(string, tag = "6")]
    pub signature: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RoundStage {
    Unspecified = 0,
    Registration = 1,
    Finalization = 2,
    Finalized = 3,
    Failed = 4,
}
impl RoundStage {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ROUND_STAGE_UNSPECIFIED",
            Self::Registration => "ROUND_STAGE_REGISTRATION",
            Self::Finalization => "ROUND_STAGE_FINALIZATION",
            Self::Finalized => "ROUND_STAGE_FINALIZED",
            Self::Failed => "ROUND_STAGE_FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROUND_STAGE_UNSPECIFIED" => Some(Self::Unspecified),
            "ROUND_STAGE_REGISTRATION" => Some(Self::Registration),
            "ROUND_STAGE_FINALIZATION" => Some(Self::Finalization),
            "ROUND_STAGE_FINALIZED" => Some(Self::Finalized),
            "ROUND_STAGE_FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetScheduledSweepRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetScheduledSweepResponse {
    #[prost(message, repeated, tag = "1")]
    pub sweeps: ::prost::alloc::vec::Vec<ScheduledSweep>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundDetailsRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundDetailsResponse {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub forfeited_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub total_vtxos_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub total_exit_amount: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub fees_amount: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "7")]
    pub inputs_vtxos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "8")]
    pub outputs_vtxos: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "9")]
    pub exit_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetRoundsRequest {
    #[prost(int64, tag = "1")]
    pub after: i64,
    #[prost(int64, tag = "2")]
    pub before: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundsResponse {
    #[prost(string, repeated, tag = "1")]
    pub rounds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateNoteRequest {
    #[prost(uint32, tag = "1")]
    pub amount: u32,
    #[prost(uint32, tag = "2")]
    pub quantity: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateNoteResponse {
    #[prost(string, repeated, tag = "1")]
    pub notes: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMarketHourConfigRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetMarketHourConfigResponse {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<MarketHourConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateMarketHourConfigRequest {
    #[prost(message, optional, tag = "1")]
    pub config: ::core::option::Option<MarketHourConfig>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UpdateMarketHourConfigResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketHourConfig {
    #[prost(message, optional, tag = "1")]
    pub start_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "2")]
    pub end_time: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "3")]
    pub period: ::core::option::Option<::prost_types::Duration>,
    #[prost(message, optional, tag = "4")]
    pub round_interval: ::core::option::Option<::prost_types::Duration>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTxRequestQueueRequest {
    #[prost(string, repeated, tag = "1")]
    pub request_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTxRequestQueueResponse {
    #[prost(message, repeated, tag = "1")]
    pub requests: ::prost::alloc::vec::Vec<TxRequestInfo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteTxRequestsRequest {
    #[prost(string, repeated, tag = "1")]
    pub request_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteTxRequestsResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WithdrawResponse {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
/// Generated client implementations.
pub mod admin_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct AdminServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AdminServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AdminServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AdminServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            AdminServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_scheduled_sweep(
            &mut self,
            request: impl tonic::IntoRequest<super::GetScheduledSweepRequest>,
        ) -> std::result::Result<tonic::Response<super::GetScheduledSweepResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetScheduledSweep");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetScheduledSweep"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_round_details(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundDetailsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundDetailsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetRoundDetails");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetRoundDetails"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_rounds(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetRounds");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetRounds"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create_note(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateNoteRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateNoteResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/CreateNote");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "CreateNote"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_market_hour_config(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMarketHourConfigRequest>,
        ) -> std::result::Result<tonic::Response<super::GetMarketHourConfigResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetMarketHourConfig");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "GetMarketHourConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_market_hour_config(
            &mut self,
            request: impl tonic::IntoRequest<super::UpdateMarketHourConfigRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UpdateMarketHourConfigResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/UpdateMarketHourConfig");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.AdminService",
                "UpdateMarketHourConfig",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_tx_request_queue(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTxRequestQueueRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTxRequestQueueResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/GetTxRequestQueue");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "GetTxRequestQueue"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_tx_requests(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteTxRequestsRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteTxRequestsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.AdminService/DeleteTxRequests");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "DeleteTxRequests"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn withdraw(
            &mut self,
            request: impl tonic::IntoRequest<super::WithdrawRequest>,
        ) -> std::result::Result<tonic::Response<super::WithdrawResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.AdminService/Withdraw");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.AdminService", "Withdraw"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub vtxo_tree_expiry: i64,
    #[prost(int64, tag = "3")]
    pub unilateral_exit_delay: i64,
    #[prost(int64, tag = "4")]
    pub round_interval: i64,
    #[prost(string, tag = "5")]
    pub network: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub dust: i64,
    #[prost(string, tag = "7")]
    pub forfeit_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "8")]
    pub market_hour: ::core::option::Option<MarketHour>,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    /// -1 means native dust limit (default)
    #[prost(int64, tag = "10")]
    pub utxo_min_amount: i64,
    /// -1 means no limit (default), 0 means boarding not allowed
    #[prost(int64, tag = "11")]
    pub utxo_max_amount: i64,
    /// -1 means native dust limit (default)
    #[prost(int64, tag = "12")]
    pub vtxo_min_amount: i64,
    /// -1 means no limit (default)
    #[prost(int64, tag = "13")]
    pub vtxo_max_amount: i64,
    #[prost(int64, tag = "14")]
    pub boarding_exit_delay: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardingAddressRequest {
    #[prost(string, tag = "1")]
    pub pubkey: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBoardingAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub taproot_tree: ::core::option::Option<Tapscripts>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterIntentRequest {
    /// BIP322 signature embeds the outpoints and the proof of funds
    #[prost(message, optional, tag = "1")]
    pub bip322_signature: ::core::option::Option<Bip322Signature>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterIntentResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeleteIntentRequest {
    #[prost(oneof = "delete_intent_request::Proof", tags = "1, 2")]
    pub proof: ::core::option::Option<delete_intent_request::Proof>,
}
/// Nested message and enum types in `DeleteIntentRequest`.
pub mod delete_intent_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Proof {
        #[prost(string, tag = "1")]
        IntentId(::prost::alloc::string::String),
        #[prost(message, tag = "2")]
        Bip322Signature(super::Bip322Signature),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeleteIntentResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterInputsForNextRoundRequest {
    #[prost(message, repeated, tag = "1")]
    pub inputs: ::prost::alloc::vec::Vec<Input>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterInputsForNextRoundResponse {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfirmRegistrationRequest {
    #[prost(string, tag = "1")]
    pub intent_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfirmRegistrationResponse {
    #[prost(string, tag = "1")]
    pub blinded_creds: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterOutputsForNextRoundRequest {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// List of receivers for to convert to leaves in the next VTXO tree.
    #[prost(message, repeated, tag = "2")]
    pub outputs: ::prost::alloc::vec::Vec<Output>,
    /// set only if offchain outputs
    #[prost(string, repeated, tag = "3")]
    pub cosigners_public_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RegisterOutputsForNextRoundResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tree_nonces: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitTreeNoncesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesRequest {
    #[prost(string, tag = "1")]
    pub round_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tree_signatures: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitTreeSignaturesResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitSignedForfeitTxsRequest {
    /// Forfeit txs signed by the user.
    #[prost(string, repeated, tag = "1")]
    pub signed_forfeit_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The user has to sign also the round tx if he registerd a boarding UTXO.
    #[prost(string, optional, tag = "2")]
    pub signed_round_tx: ::core::option::Option<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SubmitSignedForfeitTxsResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetEventStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventStreamResponse {
    #[prost(
        oneof = "get_event_stream_response::Event",
        tags = "1, 2, 3, 4, 5, 6, 7, 8"
    )]
    pub event: ::core::option::Option<get_event_stream_response::Event>,
}
/// Nested message and enum types in `GetEventStreamResponse`.
pub mod get_event_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        BatchStarted(super::BatchStartedEvent),
        #[prost(message, tag = "2")]
        RoundFinalization(super::RoundFinalizationEvent),
        #[prost(message, tag = "3")]
        RoundFinalized(super::RoundFinalizedEvent),
        #[prost(message, tag = "4")]
        RoundFailed(super::RoundFailed),
        #[prost(message, tag = "5")]
        RoundSigning(super::RoundSigningEvent),
        #[prost(message, tag = "6")]
        RoundSigningNoncesGenerated(super::RoundSigningNoncesGeneratedEvent),
        #[prost(message, tag = "7")]
        BatchTree(super::BatchTreeEvent),
        #[prost(message, tag = "8")]
        BatchTreeSignature(super::BatchTreeSignatureEvent),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOffchainTxRequest {
    #[prost(string, tag = "1")]
    pub virtual_tx: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitOffchainTxResponse {
    #[prost(string, tag = "1")]
    pub signed_virtual_tx: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub signed_checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FinalizeOffchainTxRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub checkpoint_txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FinalizeOffchainTxResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionsStreamResponse {
    #[prost(oneof = "get_transactions_stream_response::Tx", tags = "1, 2")]
    pub tx: ::core::option::Option<get_transactions_stream_response::Tx>,
}
/// Nested message and enum types in `GetTransactionsStreamResponse`.
pub mod get_transactions_stream_response {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Tx {
        #[prost(message, tag = "1")]
        Round(super::RoundTransaction),
        #[prost(message, tag = "2")]
        Redeem(super::RedeemTransaction),
    }
}
/// Generated client implementations.
pub mod ark_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ArkServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ArkServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ArkServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ArkServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ArkServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetInfo");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_boarding_address(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBoardingAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBoardingAddressResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetBoardingAddress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetBoardingAddress"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::RegisterIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/RegisterIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "RegisterIntent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delete_intent(
            &mut self,
            request: impl tonic::IntoRequest<super::DeleteIntentRequest>,
        ) -> std::result::Result<tonic::Response<super::DeleteIntentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/DeleteIntent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "DeleteIntent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_inputs_for_next_round(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterInputsForNextRoundRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterInputsForNextRoundResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.ArkService/RegisterInputsForNextRound",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "RegisterInputsForNextRound",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn confirm_registration(
            &mut self,
            request: impl tonic::IntoRequest<super::ConfirmRegistrationRequest>,
        ) -> std::result::Result<tonic::Response<super::ConfirmRegistrationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/ConfirmRegistration");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "ConfirmRegistration"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn register_outputs_for_next_round(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterOutputsForNextRoundRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterOutputsForNextRoundResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.ArkService/RegisterOutputsForNextRound",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "RegisterOutputsForNextRound",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_tree_nonces(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeNoncesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeNoncesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeNonces");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeNonces"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_tree_signatures(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTreeSignaturesRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTreeSignaturesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitTreeSignatures");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitTreeSignatures"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_signed_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitSignedForfeitTxsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SubmitSignedForfeitTxsResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitSignedForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "SubmitSignedForfeitTxs",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_event_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetEventStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetEventStream");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "GetEventStream"));
            self.inner.server_streaming(req, path, codec).await
        }
        pub async fn submit_offchain_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitOffchainTxRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitOffchainTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ArkService/SubmitOffchainTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "SubmitOffchainTx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn finalize_offchain_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::FinalizeOffchainTxRequest>,
        ) -> std::result::Result<tonic::Response<super::FinalizeOffchainTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/FinalizeOffchainTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ArkService", "FinalizeOffchainTx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transactions_stream(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionsStreamRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetTransactionsStreamResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ArkService/GetTransactionsStream");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ArkService",
                "GetTransactionsStream",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenSeedRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenSeedResponse {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct CreateResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RestoreRequest {
    #[prost(string, tag = "1")]
    pub seed: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub password: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub gap_limit: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RestoreResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnlockRequest {
    #[prost(string, tag = "1")]
    pub password: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnlockResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct LockResponse {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStatusRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetStatusResponse {
    #[prost(bool, tag = "1")]
    pub initialized: bool,
    #[prost(bool, tag = "2")]
    pub unlocked: bool,
    #[prost(bool, tag = "3")]
    pub synced: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DeriveAddressRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeriveAddressResponse {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetBalanceRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Balance {
    #[prost(string, tag = "1")]
    pub locked: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub available: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetBalanceResponse {
    #[prost(message, optional, tag = "1")]
    pub main_account: ::core::option::Option<Balance>,
    #[prost(message, optional, tag = "2")]
    pub connectors_account: ::core::option::Option<Balance>,
}
/// Generated client implementations.
pub mod wallet_initializer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletInitializerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletInitializerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletInitializerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletInitializerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletInitializerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn gen_seed(
            &mut self,
            request: impl tonic::IntoRequest<super::GenSeedRequest>,
        ) -> std::result::Result<tonic::Response<super::GenSeedResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GenSeed");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GenSeed",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn create(
            &mut self,
            request: impl tonic::IntoRequest<super::CreateRequest>,
        ) -> std::result::Result<tonic::Response<super::CreateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Create");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Create"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn restore(
            &mut self,
            request: impl tonic::IntoRequest<super::RestoreRequest>,
        ) -> std::result::Result<tonic::Response<super::RestoreResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Restore");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "Restore",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unlock(
            &mut self,
            request: impl tonic::IntoRequest<super::UnlockRequest>,
        ) -> std::result::Result<tonic::Response<super::UnlockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/Unlock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletInitializerService", "Unlock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_status(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStatusRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStatusResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.WalletInitializerService/GetStatus");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.WalletInitializerService",
                "GetStatus",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod wallet_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WalletServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WalletServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WalletServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WalletServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            WalletServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn lock(
            &mut self,
            request: impl tonic::IntoRequest<super::LockRequest>,
        ) -> std::result::Result<tonic::Response<super::LockResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/Lock");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "Lock"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn derive_address(
            &mut self,
            request: impl tonic::IntoRequest<super::DeriveAddressRequest>,
        ) -> std::result::Result<tonic::Response<super::DeriveAddressResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/DeriveAddress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "DeriveAddress"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_balance(
            &mut self,
            request: impl tonic::IntoRequest<super::GetBalanceRequest>,
        ) -> std::result::Result<tonic::Response<super::GetBalanceResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.WalletService/GetBalance");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.WalletService", "GetBalance"));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundResponse {
    #[prost(message, optional, tag = "1")]
    pub round: ::core::option::Option<Round>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundByIdRequest {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetRoundByIdResponse {
    #[prost(message, optional, tag = "1")]
    pub round: ::core::option::Option<Round>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVtxosRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListVtxosResponse {
    #[prost(message, repeated, tag = "1")]
    pub spendable_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "2")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForAddressRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForAddressResponse {
    #[prost(message, repeated, tag = "2")]
    pub new_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
    #[prost(message, repeated, tag = "3")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<Vtxo>,
}
/// Generated client implementations.
pub mod explorer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct ExplorerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl ExplorerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> ExplorerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> ExplorerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            ExplorerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_round(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/GetRound");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ExplorerService", "GetRound"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_round_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetRoundByIdRequest>,
        ) -> std::result::Result<tonic::Response<super::GetRoundByIdResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/GetRoundById");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ExplorerService", "GetRoundById"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn list_vtxos(
            &mut self,
            request: impl tonic::IntoRequest<super::ListVtxosRequest>,
        ) -> std::result::Result<tonic::Response<super::ListVtxosResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/ListVtxos");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.ExplorerService", "ListVtxos"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn subscribe_for_address(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeForAddressRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SubscribeForAddressResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.ExplorerService/SubscribeForAddress");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.ExplorerService",
                "SubscribeForAddress",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxResponse {
    #[prost(int64, tag = "1")]
    pub started_at: i64,
    #[prost(int64, tag = "2")]
    pub ended_at: i64,
    #[prost(map = "uint32, message", tag = "3")]
    pub batches: ::std::collections::HashMap<u32, IndexerBatch>,
    #[prost(uint64, tag = "4")]
    pub total_input_amount: u64,
    #[prost(int32, tag = "5")]
    pub total_input_vtxos: i32,
    #[prost(uint64, tag = "6")]
    pub total_output_amount: u64,
    #[prost(int32, tag = "7")]
    pub total_output_vtxos: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetForfeitTxsRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetForfeitTxsResponse {
    #[prost(string, repeated, tag = "1")]
    pub txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorsRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetConnectorsResponse {
    #[prost(message, repeated, tag = "1")]
    pub connectors: ::prost::alloc::vec::Vec<IndexerNode>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxLeavesRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCommitmentTxLeavesResponse {
    #[prost(message, repeated, tag = "1")]
    pub leaves: ::prost::alloc::vec::Vec<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxo_tree: ::prost::alloc::vec::Vec<IndexerNode>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeLeavesRequest {
    #[prost(message, optional, tag = "1")]
    pub batch_outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoTreeLeavesResponse {
    #[prost(message, repeated, tag = "1")]
    pub leaves: ::prost::alloc::vec::Vec<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosRequest {
    #[prost(string, repeated, tag = "1")]
    pub addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bool, tag = "2")]
    pub spendable_only: bool,
    #[prost(bool, tag = "3")]
    pub spent_only: bool,
    #[prost(message, optional, tag = "4")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosByOutpointRequest {
    #[prost(string, repeated, tag = "1")]
    pub outpoints: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxosByOutpointResponse {
    #[prost(message, repeated, tag = "1")]
    pub vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionHistoryRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub start_time: i64,
    #[prost(int64, tag = "3")]
    pub end_time: i64,
    #[prost(message, optional, tag = "4")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetTransactionHistoryResponse {
    #[prost(message, repeated, tag = "1")]
    pub history: ::prost::alloc::vec::Vec<IndexerTxHistoryRecord>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoChainRequest {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVtxoChainResponse {
    #[prost(message, repeated, tag = "1")]
    pub chain: ::prost::alloc::vec::Vec<IndexerChain>,
    #[prost(int32, tag = "2")]
    pub depth: i32,
    #[prost(string, tag = "3")]
    pub root_commitment_txid: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVirtualTxsRequest {
    #[prost(string, repeated, tag = "1")]
    pub txids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageRequest>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVirtualTxsResponse {
    #[prost(string, repeated, tag = "1")]
    pub txs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub page: ::core::option::Option<IndexerPageResponse>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSweptCommitmentTxRequest {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSweptCommitmentTxResponse {
    #[prost(string, repeated, tag = "1")]
    pub swept_by: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexerBatch {
    #[prost(uint64, tag = "1")]
    pub total_output_amount: u64,
    #[prost(int32, tag = "2")]
    pub total_output_vtxos: i32,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
    #[prost(bool, tag = "4")]
    pub swept: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerOutpoint {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(uint32, tag = "2")]
    pub vout: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerNode {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub parent_txid: ::prost::alloc::string::String,
    #[prost(int32, tag = "4")]
    pub level: i32,
    #[prost(int32, tag = "5")]
    pub level_index: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerVtxo {
    #[prost(message, optional, tag = "1")]
    pub outpoint: ::core::option::Option<IndexerOutpoint>,
    #[prost(int64, tag = "2")]
    pub created_at: i64,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    #[prost(string, tag = "5")]
    pub script: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub is_leaf: bool,
    #[prost(bool, tag = "7")]
    pub is_swept: bool,
    #[prost(bool, tag = "8")]
    pub is_spent: bool,
    #[prost(string, tag = "9")]
    pub spent_by: ::prost::alloc::string::String,
    #[prost(string, tag = "10")]
    pub commitment_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerChain {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub spends: ::prost::alloc::vec::Vec<IndexerChainedTx>,
    #[prost(int64, tag = "3")]
    pub expires_at: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerChainedTx {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(enumeration = "IndexerChainedTxType", tag = "2")]
    pub r#type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexerTxHistoryRecord {
    #[prost(enumeration = "IndexerTxType", tag = "3")]
    pub r#type: i32,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    #[prost(int64, tag = "5")]
    pub created_at: i64,
    #[prost(bool, tag = "6")]
    pub is_settled: bool,
    #[prost(string, tag = "7")]
    pub settled_by: ::prost::alloc::string::String,
    #[prost(oneof = "indexer_tx_history_record::Key", tags = "1, 2")]
    pub key: ::core::option::Option<indexer_tx_history_record::Key>,
}
/// Nested message and enum types in `IndexerTxHistoryRecord`.
pub mod indexer_tx_history_record {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Key {
        #[prost(string, tag = "1")]
        CommitmentTxid(::prost::alloc::string::String),
        #[prost(string, tag = "2")]
        VirtualTxid(::prost::alloc::string::String),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexerPageRequest {
    #[prost(int32, tag = "1")]
    pub size: i32,
    #[prost(int32, tag = "2")]
    pub index: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct IndexerPageResponse {
    #[prost(int32, tag = "1")]
    pub current: i32,
    #[prost(int32, tag = "2")]
    pub next: i32,
    #[prost(int32, tag = "3")]
    pub total: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForScriptsRequest {
    #[prost(string, repeated, tag = "1")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// if set, update an existing subscription
    #[prost(string, tag = "2")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeForScriptsResponse {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnsubscribeForScriptsRequest {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
    /// if empty, unsubscribe all scripts
    #[prost(string, repeated, tag = "2")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct UnsubscribeForScriptsResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionRequest {
    #[prost(string, tag = "1")]
    pub subscription_id: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetSubscriptionResponse {
    #[prost(string, tag = "1")]
    pub txid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub scripts: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub new_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
    #[prost(message, repeated, tag = "4")]
    pub spent_vtxos: ::prost::alloc::vec::Vec<IndexerVtxo>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexerTxType {
    Unspecified = 0,
    Received = 1,
    Sent = 2,
}
impl IndexerTxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXER_TX_TYPE_UNSPECIFIED",
            Self::Received => "INDEXER_TX_TYPE_RECEIVED",
            Self::Sent => "INDEXER_TX_TYPE_SENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXER_TX_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXER_TX_TYPE_RECEIVED" => Some(Self::Received),
            "INDEXER_TX_TYPE_SENT" => Some(Self::Sent),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexerChainedTxType {
    Unspecified = 0,
    Virtual = 1,
    Commitment = 2,
}
impl IndexerChainedTxType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED",
            Self::Virtual => "INDEXER_CHAINED_TX_TYPE_VIRTUAL",
            Self::Commitment => "INDEXER_CHAINED_TX_TYPE_COMMITMENT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INDEXER_CHAINED_TX_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INDEXER_CHAINED_TX_TYPE_VIRTUAL" => Some(Self::Virtual),
            "INDEXER_CHAINED_TX_TYPE_COMMITMENT" => Some(Self::Commitment),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod indexer_service_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value
    )]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct IndexerServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl IndexerServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> IndexerServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> IndexerServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            IndexerServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn get_commitment_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommitmentTxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCommitmentTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetCommitmentTx");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetCommitmentTx"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_forfeit_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetForfeitTxsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetForfeitTxsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetForfeitTxs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetForfeitTxs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_connectors(
            &mut self,
            request: impl tonic::IntoRequest<super::GetConnectorsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetConnectorsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetConnectors");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetConnectors"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_commitment_tx_leaves(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCommitmentTxLeavesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCommitmentTxLeavesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/GetCommitmentTxLeaves",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetCommitmentTxLeaves",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_vtxo_tree(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoTreeRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoTreeResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoTree");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxoTree"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_vtxo_tree_leaves(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoTreeLeavesRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoTreeLeavesResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoTreeLeaves");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetVtxoTreeLeaves",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_vtxos(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxosRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxosResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxos");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxos"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_vtxos_by_outpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxosByOutpointRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxosByOutpointResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxosByOutpoint");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetVtxosByOutpoint",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_transaction_history(
            &mut self,
            request: impl tonic::IntoRequest<super::GetTransactionHistoryRequest>,
        ) -> std::result::Result<tonic::Response<super::GetTransactionHistoryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/GetTransactionHistory",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetTransactionHistory",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_vtxo_chain(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVtxoChainRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVtxoChainResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVtxoChain");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVtxoChain"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_virtual_txs(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVirtualTxsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetVirtualTxsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetVirtualTxs");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetVirtualTxs"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_swept_commitment_tx(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSweptCommitmentTxRequest>,
        ) -> std::result::Result<tonic::Response<super::GetSweptCommitmentTxResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetSweptCommitmentTx");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "GetSweptCommitmentTx",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn subscribe_for_scripts(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeForScriptsRequest>,
        ) -> std::result::Result<tonic::Response<super::SubscribeForScriptsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/SubscribeForScripts");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "SubscribeForScripts",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unsubscribe_for_scripts(
            &mut self,
            request: impl tonic::IntoRequest<super::UnsubscribeForScriptsRequest>,
        ) -> std::result::Result<tonic::Response<super::UnsubscribeForScriptsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/ark.v1.IndexerService/UnsubscribeForScripts",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "ark.v1.IndexerService",
                "UnsubscribeForScripts",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn get_subscription(
            &mut self,
            request: impl tonic::IntoRequest<super::GetSubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetSubscriptionResponse>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::unknown(format!("Service was not ready: {}", e.into()))
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/ark.v1.IndexerService/GetSubscription");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("ark.v1.IndexerService", "GetSubscription"));
            self.inner.server_streaming(req, path, codec).await
        }
    }
}
